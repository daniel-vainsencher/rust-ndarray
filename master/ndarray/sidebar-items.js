initSidebarItems({"constant":[["S","Slice value for the full range of an axis."]],"enum":[["ShapeError","An error that can be produced by `.into_shape()`"],["StrideError","An error to describe invalid stride states"]],"fn":[["arr0","Return a zero-dimensional array with the element `x`."],["arr1","Return a one-dimensional array with elements from `xs`."],["arr2","Return a two-dimensional array with elements from `xs`."],["arr3","Return a three-dimensional array with elements from `xs`.**Panics** if the slices are not all of the same length."],["aview0","Return a zero-dimensional array view borrowing `x`."],["aview1","Return a one-dimensional array view with elements borrowing `xs`."],["aview2","Return a two-dimensional array view with elements borrowing `xs`."],["aview_mut1","Return a one-dimensional read-write array view with elements borrowing `xs`."],["rcarr1","Return a one-dimensional array with elements from `xs`."],["rcarr2","Return a two-dimensional array with elements from `xs`."],["rcarr3","Return a three-dimensional array with elements from `xs`."],["zeros","Return an array filled with zeros"]],"macro":[["s!","Slice argument constructor.`s![]` takes a list of ranges, separated by comma, with optional strides that are separated from the range by a semicolon. It is converted into a slice argument with type `&[Si; N]`.Each range uses signed indices, where a negative value is counted from the end of the axis. Strides are also signed and may be negative, but must not be zero.For example, if an array has two axes, the slice argument is passed as type `&[Si; 2]`.For example `s![a..b;c, d..e]` is equivalent to `&[Si(a, Some(b), c), Si(d, Some(e), 1)]`."]],"mod":[["blas","Experimental BLAS (Basic Linear Algebra Subprograms) integration***Requires `features = \"rblas\"`***Depends on crate `rblas`, (docs).Use the methods in trait `AsBlas` to convert an array into a view that implements rblas’ `Vector` or `Matrix` traits.Blas supports strided vectors and matrices; Matrices need to be contiguous in their lowest dimension, so they will be copied into c-contiguous layout automatically if needed. You should be able to use blocks sliced out from a larger matrix without copying. Use the transpose flags in blas instead of transposing with `ndarray`.Blas has its own error reporting system and will not panic on errors (that I know), instead output its own error conditions, for example on dimension mismatch in a matrix multiplication."],["linalg","***Deprecated: linalg is not in good shape.***A few linear algebra operations on two-dimensional arrays."]],"struct":[["ArrayBase","An *N*-dimensional array.The array is a general container of elements. It cannot grow or shrink, but can be sliced into subsets of its data. The array supports arithmetic operations by applying them elementwise.The `ArrayBase<S, D>` is parameterized by: - `S` for the data container - `D` for the number of dimensionsType aliases `OwnedArray`, `RcArray`, `ArrayView`, and `ArrayViewMut` refer to `ArrayBase` with different types for the data storage.`OwnedArray` and `RcArray``OwnedArray` owns the underlying array elements directly (just like a `Vec`), while `RcArray` is a an array with reference counted data. `RcArray` can act both as an owner or as a view in that regard. Sharing requires that it uses copy-on-write for mutable operations. Calling a method for mutating elements on `RcArray`, for example `view_mut()` or `get_mut()`, will break sharing and require a clone of the data (if it is not uniquely held).Note that all `ArrayBase` variants can change their view (slicing) of the data freely, even when their data can’t be mutated.Indexing and DimensionArray indexes are represented by the types `Ix` and `Ixs` (signed).The dimensionality of the array determines the number of *axes*, for example a 2D array has two axes. These are listed in “big endian” order, so that the greatest dimension is listed first, the lowest dimension with the most rapidly varying index is the last.In a 2D array the index of each element is `(row, column)` as seen in this 3 × 3 example:The number of axes for an array is fixed by the `D` parameter: `Ix` for a 1D array, `(Ix, Ix)` for a 2D array etc. The `D` type is also used for element indices in `.get()` and `array[index]`. The dimension type `Vec<Ix>` allows a dynamic number of axes.The default memory order of an array is *row major* order, where each row is contiguous in memory. A *column major* (a.k.a. fortran) memory order array has columns (or, in general, the outermost axis) with contiguous elements.SlicingYou can use slicing to create a view of a subset of the data in the array. Slicing methods include `.slice()`, `.islice()`, `.slice_mut()`.The slicing argument can be passed using the macro `s![]`, which will be used in all examples. (The explicit form is a reference to a fixed size array of `Si`; see its docs for more information.)SubviewsSubview methods allow you to restrict the array view while removing one axis from the array. Subview methods include `.subview()`, `.isubview()`, `.subview_mut()`.Subview takes two arguments: `axis` and `index`.`.isubview()` modifies the view in the same way as `subview()`, but since it is *in place*, it cannot remove the collapsed axis. It becomes an axis of length 1.`.outer_iter()` is an iterator of every subview along the zeroth (outer) axis, while `.axis_iter()` is an iterator of every subview along a specific axis.Arithmetic OperationsArrays support all arithmetic operations the same way: they apply elementwise.Since the trait implementations are hard to overview, here is a summary.Let `A` be an array or view of any kind. Let `B` be a mutable array (that is, either `OwnedArray`, `RcArray`, or `ArrayViewMut`) The following combinations of operands are supported for an arbitrary binary operator denoted by `@`.`&A @ &A` which produces a new `OwnedArray` `B @ A` which consumes `B`, updates it with the result, and returns it `B @ &A` which consumes `B`, updates it with the result, and returns it `B @= &A` which performs an arithmetic operation in place (requires `features = \"assign_ops\"`) The trait `Scalar` marks types that can be used in arithmetic with arrays directly. For a scalar `K` the following combinations of operands are supported (scalar can be on either side).`&A @ K` or `K @ &A` which produces a new `OwnedArray` `B @ K` or `K @ B` which consumes `B`, updates it with the result and returns it `B @= K` which performs an arithmetic operation in place (requires `features = \"assign_ops\"`) BroadcastingArrays support limited *broadcasting*, where arithmetic operations with array operands of different sizes can be carried out by repeating the elements of the smaller dimension array. See `.broadcast()` for a more detailed description."],["AxisChunksIter","An iterator that traverses over the specified axis and yields views of the specified size on this axis.For example, in a 2 × 8 × 3 array, if the axis of iteration is 1 and the chunk size is 2, the yielded elements are 2 × 2 × 3 views (and there are 4 in total).Iterator element type is `ArrayView<'a, A, D>`.See `.axis_chunks_iter()` for more information."],["AxisChunksIterMut","An iterator that traverses over the specified axis and yields mutable views of the specified size on this axis.For example, in a 2 × 8 × 3 array, if the axis of iteration is 1 and the chunk size is 2, the yielded elements are 2 × 2 × 3 views (and there are 4 in total).Iterator element type is `ArrayViewMut<'a, A, D>`.See `.axis_chunks_iter_mut()` for more information."],["Elements","An iterator over the elements of an array.Iterator element type is `&'a A`.See `.iter()` for more information."],["ElementsMut","An iterator over the elements of an array (mutable).Iterator element type is `&'a mut A`.See `.iter_mut()` for more information."],["Indexed","An iterator over the indexes and elements of an array.See `.indexed_iter()` for more information."],["IndexedMut","An iterator over the indexes and elements of an array (mutable).See `.indexed_iter_mut()` for more information."],["Indexes","An iterator over the indexes of an array shape.Iterator element type is `D`."],["InnerIter","An iterator that traverses over all dimensions but the innermost, and yields each inner row.See `.inner_iter()` for more information."],["InnerIterMut","An iterator that traverses over all dimensions but the innermost, and yields each inner row (mutable).See `.inner_iter_mut()` for more information."],["OuterIter","An iterator that traverses over the outermost dimension and yields each subview.For example, in a 2 × 2 × 3 array, the iterator element is a 2 × 3 subview (and there are 2 in total).Iterator element type is `ArrayView<'a, A, D>`.See `.outer_iter()` for more information."],["OuterIterMut","An iterator that traverses over the outermost dimension and yields each subview (mutable).For example, in a 2 × 2 × 3 array, the iterator element is a 2 × 3 subview (and there are 2 in total).Iterator element type is `ArrayViewMut<'a, A, D>`.See `.outer_iter_mut()` for more information."],["Si","A slice, a description of a range of an array axis.Fields are `begin`, `end` and `stride`, where negative `begin` or `end` indexes are counted from the back of the axis.If `end` is `None`, the slice extends to the end of the axis.See also the `s![] macro`, a convenient way to specify an array of `Si`.Examples`Si(0, None, 1)` is the full range of an axis. Python equivalent is `[:]`. Macro equivalent is `s![..]`.`Si(a, Some(b), 2)` is every second element from `a` until `b`. Python equivalent is `[a:b:2]`. Macro equivalent is `s![a..b;2]`.`Si(a, None, -1)` is every element, from `a` until the end, in reverse order. Python equivalent is `[a::-1]`. Macro equivalent is `s![a..;-1]`.The constant `S` is a shorthand for the full range of an axis."],["ViewRepr","Array view’s representation."]],"trait":[["Data","Array’s inner representation.***Note:*** `Data` is not an extension interface at this point. Traits in Rust can serve many different roles. This trait is public because it is used as a bound on public methods."],["DataClone","Clone an Array’s storage."],["DataMut","Array’s writable inner representation."],["DataOwned","Array representation that is a unique or shared owner of its data."],["DataShared","Array representation that is a lightweight view."],["Dimension","Trait for the shape and index types of arrays.`unsafe` because of the assumptions in the default methods.***Don't implement or call methods in this trait, its interface is internal to the crate and will evolve at will.***"],["FixedInitializer","Fixed-size array used for array initialization"],["NdIndex","A tuple or fixed size array that can be used to index an array.**Note** the blanket implementation that's not visible in rustdoc: `impl<D> NdIndex for D where D: Dimension { ... }`"],["RemoveAxis","Helper trait to define a larger-than relation for array shapes: removing one axis from *Self* gives smaller dimension *Smaller*."],["Scalar","Elements that can be used as direct operands in arithmetic with arrays.This trait ***does not*** limit which elements can be stored in an `ArrayBase`.`Scalar` simply determines which types are applicable for direct operator overloading, e.g. `B @ K` or `B @= K`  where `B` is a mutable array, `K` a scalar, and `@` arbitrary arithmetic operator that the scalar supports.Left hand side operands must instead be implemented one by one (it does not involve the `Scalar` trait). Scalar left hand side operations: `K @ &A` and `K @ B`, are implemented for the primitive numerical types and for `Complex<f32>, Complex<f64>`.Non-`Scalar` types can still participate in arithmetic as array elements in in array-array operations."]],"type":[["Array","***Deprecated: Use `RcArray` instead***Array where the data is reference counted and copy on write, it can act as both an owner as the data as well as a lightweight view."],["ArrayView","A lightweight array view.`ArrayView` implements `IntoIterator`."],["ArrayViewMut","A lightweight read-write array view.`ArrayViewMut` implements `IntoIterator`."],["Ix","Array index type"],["Ixs","Array index type (signed)"],["OwnedArray","Array where the data is owned uniquely."],["RcArray","Array where the data is reference counted and copy on write, it can act as both an owner as the data as well as a lightweight view."]]});